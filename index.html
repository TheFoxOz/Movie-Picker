<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Movie Picker</title>
    <!-- PWA Manifest Link -->
    <link rel="manifest" href="manifest.json">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #f97316; /* Orange-600 */
            --bg-color: #1f2937; /* Gray-800 */
            --card-color: #374151; /* Gray-700 */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: #f3f4f6; /* Gray-100 */
            height: 100vh;
            overflow: hidden; /* Prevent body scroll, let content scroll if needed */
        }
        .container {
            max-width: 420px; /* Mobile first design */
            margin: auto;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .nav-link {
            transition: all 0.2s;
            cursor: pointer;
        }
        .nav-link.active {
            border-bottom: 3px solid var(--primary-color);
            color: var(--primary-color);
            font-weight: 700;
        }
        /* Custom styles for the movie card stack and swiping */
        #movie-stack {
            flex-grow: 1;
            position: relative;
            /* Calculate height dynamically based on viewport minus header/padding */
            height: calc(100vh - 170px); 
            margin-top: 1rem;
            padding: 0 1rem;
        }
        .movie-card {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 380px;
            height: 100%; /* Takes up full height of #movie-stack */
            max-height: 100%; /* Ensure it respects container limit */
            background-color: var(--card-color);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            border-radius: 1.5rem;
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            touch-action: none; /* Required for mobile dragging */
        }
        .movie-card.loading {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            text-align: center;
        }
        .movie-card-image {
            height: 60%;
            border-radius: 1.5rem 1.5rem 0 0;
            background-size: cover;
            background-position: center;
        }
        .movie-card-info {
            padding: 1rem;
            height: 40%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        /* Spinner for loading state */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div class="container">
    <!-- Header/Navigation -->
    <header class="bg-gray-900 shadow-lg p-4 sticky top-0 z-10 rounded-b-xl">
        <h1 class="text-2xl font-bold text-center text-white">Movie Picker</h1>
        <!-- Display User ID for debugging and matching purposes -->
        <p id="user-display" class="text-xs text-center text-gray-500 mt-1 truncate">Loading User ID...</p>
        <nav class="flex justify-around mt-4 text-gray-400 text-lg">
            <span id="nav-swipe" class="nav-link active p-2" data-tab="swipe">Swipe</span>
            <span id="nav-settings" class="nav-link p-2" data-tab="settings">Settings</span>
            <span id="nav-list" class="nav-link p-2" data-tab="list">List</span>
        </nav>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow p-4 overflow-y-hidden flex flex-col">

        <!-- Swipe Tab -->
        <section id="tab-swipe" class="tab-content h-full flex flex-col flex-grow">
            <div id="movie-stack">
                <!-- Movie cards will be inserted here by JavaScript -->
                <div id="loading-card" class="movie-card loading z-50">
                    <div class="text-center p-8">
                        <div class="spinner mx-auto mb-4"></div>
                        <p>Finding available movies...</p>
                        <p class="text-sm text-gray-400 mt-2">Make sure your settings are saved!</p>
                    </div>
                </div>
                <div id="no-movies-card" class="movie-card loading z-0 hidden">
                    <p class="text-center p-8 text-white">
                        No movies found matching your current filters. <br><br>
                        Try adjusting your **Settings** or try again later.
                    </p>
                </div>
            </div>
        </section>

        <!-- Settings Tab (Scrollable) -->
        <section id="tab-settings" class="tab-content hidden p-4 overflow-y-auto">
            <h2 class="text-xl font-semibold mb-4 text-white">Your Viewing Preferences</h2>

            <div id="auth-status" class="mb-4 text-sm text-gray-400">Loading authentication status...</div>

            <!-- Country Code Setting -->
            <div class="mb-6">
                <label for="country-code" class="block text-sm font-medium text-gray-300 mb-2">Your Country (for streaming region):</label>
                <input type="text" id="country-code" class="w-full p-2 rounded-lg bg-gray-700 border border-gray-600 text-white placeholder-gray-400" placeholder="e.g., US, FR, GB" maxlength="2" value="US">
                <p class="text-xs text-gray-400 mt-1">Uses ISO 3166-1 2-letter code.</p>
            </div>

            <!-- Streaming Platform Selection -->
            <div class="mb-6">
                <h3 class="text-md font-medium text-gray-300 mb-2">Your Active Streaming Platforms:</h3>
                <div id="platforms-container" class="space-y-2">
                    <!-- Platforms checkboxes will be dynamically inserted here -->
                </div>
            </div>

            <button id="save-settings-btn" class="w-full py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-xl transition duration-200 shadow-xl">
                Save Preferences
            </button>
            <p id="save-message" class="mt-4 text-center text-sm hidden"></p>
        </section>

        <!-- List Tab (Scrollable) -->
        <section id="tab-list" class="tab-content hidden p-4 overflow-y-auto">
            <h2 class="text-xl font-semibold mb-4 text-white">Your Final Matches</h2>
            <div id="final-list" class="space-y-4">
                <p class="text-gray-400 text-center p-4" id="no-matches-msg">No matches yet. Start swiping!</p>
            </div>
        </section>

    </main>
</div>

<!-- Firebase SDKs -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query, updateDoc, arrayUnion } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Set Firestore log level to debug for development
    setLogLevel('Debug');

    // --- GLOBAL CONSTANTS ---
    const TMDB_API_KEY = 'fb172ed62b2cd58897d484ad8ba0cf60'; 
    const TMDB_BASE_URL = 'https://api.themoviedb.org/3';
    const TMDB_IMAGE_BASE_URL = 'https://image.tmdb.org/t/p/w500';

    const PROVIDER_MAP = [
        { id: 8, name: "Netflix", logo: "https://placehold.co/40x40/e50914/ffffff?text=N" },
        { id: 9, name: "Amazon Prime Video", logo: "https://placehold.co/40x40/00a8e1/ffffff?text=P" },
        { id: 337, name: "Disney Plus", logo: "https://placehold.co/40x40/113ccf/ffffff?text=D+" },
        { id: 384, name: "HBO Max", logo: "https://placehold.co/40x40/7300e5/ffffff?text=HBO" },
        { id: 15, name: "Hulu", logo: "https://placehold.co/40x40/1ce783/ffffff?text=H" },
        { id: 350, name: "Apple TV Plus", logo: "https://placehold.co/40x40/000000/ffffff?text=A+" },
        { id: 30, name: "discovery+", logo: "https://placehold.co/40x40/000000/ffffff?text=D" }
        // Add more common providers as needed
    ];

    // --- FIREBASE INITIALIZATION & STATE ---
    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let app;
    let auth;
    let db;
    let userId = null;
    let isAuthReady = false;

    let currentPreferences = {
        countryCode: 'US',
        platformIds: PROVIDER_MAP.map(p => p.id) // Default: Select all
    };
    let movieDeck = [];
    let movieDeckMap = new Map(); // Store full movie data for easy lookup by ID
    let currentMovieIndex = 0;
    const movieStackEl = document.getElementById('movie-stack');
    const loadingCardEl = document.getElementById('loading-card');
    const noMoviesCardEl = document.getElementById('no-movies-card');
    const authStatusEl = document.getElementById('auth-status');
    const userDisplayEl = document.getElementById('user-display');
    const finalListEl = document.getElementById('final-list');

    // --- FIREBASE SETUP ---
    async function initializeFirebase() {
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase initialization or sign-in failed:", error);
            authStatusEl.textContent = `Error: ${error.message}`;
        }
    }

    // Authentication State Listener
    onAuthStateChanged(auth, (user) => {
        if (user) {
            userId = user.uid;
            authStatusEl.textContent = `Authenticated User ID: ${userId}`;
            userDisplayEl.textContent = `Your User ID: ${userId}`;
            isAuthReady = true;
            
            // Load and then fetch after user is confirmed
            loadUserPreferences();
            // Start listening for matches immediately
            listenForFinalList(); 
        } else {
            // Should not happen with the token/anonymous fallback, but good practice
            userId = null;
            isAuthReady = true;
            console.log("Signed out or anonymous.");
        }
    });

    // --- FIRESTORE PREFERENCES ---

    function getPreferencesDocRef() {
        if (!userId) return null;
        // Path: /artifacts/{appId}/users/{userId}/preferences/settings
        return doc(db, 'artifacts', appId, 'users', userId, 'preferences', 'settings');
    }

    // Load preferences from Firestore
    async function loadUserPreferences() {
        const docRef = getPreferencesDocRef();
        if (!docRef) return;

        try {
            const docSnap = await getDoc(docRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                currentPreferences = {
                    countryCode: data.countryCode || 'US',
                    platformIds: data.platformIds || PROVIDER_MAP.map(p => p.id)
                };
            } else {
                // Save defaults if none exist
                await saveUserPreferences(currentPreferences.countryCode, currentPreferences.platformIds, false);
            }
            updateSettingsUI();
            fetchMovies();
        } catch (error) {
            console.error("Error loading preferences:", error);
            // Fallback to defaults
            updateSettingsUI();
            fetchMovies();
        }
    }

    // Save preferences to Firestore
    async function saveUserPreferences(countryCode, platformIds, showMessage = true) {
        const docRef = getPreferencesDocRef();
        if (!docRef) {
            console.error("Cannot save preferences: User ID not available.");
            return;
        }

        const data = { countryCode, platformIds };
        currentPreferences = data;

        try {
            await setDoc(docRef, data);
            if (showMessage) {
                const msgEl = document.getElementById('save-message');
                msgEl.textContent = "Preferences saved! Refreshing movie list...";
                msgEl.classList.remove('hidden', 'text-red-500');
                msgEl.classList.add('text-green-500');
                setTimeout(() => {
                    msgEl.classList.add('hidden');
                    // Rerun movie fetching after saving
                    resetMovieDeck();
                }, 1500);
            }
        } catch (error) {
            console.error("Error saving preferences:", error);
            if (showMessage) {
                const msgEl = document.getElementById('save-message');
                msgEl.textContent = `Error saving: ${error.message}`;
                msgEl.classList.remove('hidden', 'text-green-500');
                msgEl.classList.add('text-red-500');
            }
        }
    }
    
    // --- FIRESTORE SWIPE & MATCH LOGIC ---

    // Get reference to the public movie swipe document
    function getMovieSwipesDocRef(movieId) {
        // Path: /artifacts/{appId}/public/data/swipes/{movieId}
        return doc(db, 'artifacts', appId, 'public', 'data', 'swipes', String(movieId));
    }

    // Save the user's decision to 'like' a movie in the public collection
    async function saveSwipeDecision(movieId) {
        if (!userId || !db) return;
        const docRef = getMovieSwipesDocRef(movieId);

        try {
            // Atomically add the current user's ID to the 'likers' map.
            await setDoc(docRef, { 
                likers: { 
                    [userId]: true 
                },
                movieId: movieId
            }, { merge: true });
            
            console.log(`User ${userId} liked movie ${movieId}.`);

        } catch (error) {
            console.error("Error saving swipe decision:", error);
        }
    }

    // Check if a match exists (another user has also liked this movie) and finalize it.
    async function finalizeMatch(movieId, movieData) {
        if (!userId || !db) return;
        const movieDocRef = getMovieSwipesDocRef(movieId);

        try {
            const docSnap = await getDoc(movieDocRef);
            if (docSnap.exists()) {
                const data = docSnap.data();
                const likers = data.likers || {};
                
                // Find all likers who are NOT the current user
                const otherLikers = Object.keys(likers).filter(id => id !== userId);

                if (otherLikers.length > 0) {
                    // Match found!
                    console.log(`MATCH FOUND for movie ${movieId} with user(s): ${otherLikers.join(', ')}`);

                    // Prepare match data for the private list
                    const matchData = {
                        movieId: movieId,
                        title: movieData.title,
                        poster_path: movieData.poster_path,
                        release_date: movieData.release_date,
                        overview: movieData.overview,
                        matchedWith: otherLikers,
                        timestamp: new Date().getTime()
                    };

                    // Add to the current user's private match list
                    // Path: /artifacts/{appId}/users/{userId}/matches/{movieId}
                    const userMatchDocRef = doc(db, 'artifacts', appId, 'users', userId, 'matches', String(movieId));
                    await setDoc(userMatchDocRef, matchData, { merge: true });
                    
                    // You might want to update the public swipe document to mark it as 'matched'
                    // but for simplicity, we rely on the private list for displaying matches.
                }
            }
        } catch (error) {
            console.error("Error checking or finalizing match:", error);
        }
    }

    // Real-time listener for the user's final list of matches
    function listenForFinalList() {
        if (!userId || !db) return;

        // Path: /artifacts/{appId}/users/{userId}/matches
        const matchesRef = collection(db, 'artifacts', appId, 'users', userId, 'matches');

        onSnapshot(matchesRef, (snapshot) => {
            const matches = [];
            snapshot.forEach(doc => {
                matches.push(doc.data());
            });
            // Sort by match time, newest first
            matches.sort((a, b) => b.timestamp - a.timestamp);
            renderFinalList(matches);
        }, (error) => {
            console.error("Error listening to final list:", error);
        });
    }

    // --- UI FUNCTIONS ---

    // Navigation logic
    document.querySelectorAll('.nav-link').forEach(link => {
        link.addEventListener('click', () => {
            const targetTab = link.getAttribute('data-tab');

            // Update navigation links
            document.querySelectorAll('.nav-link').forEach(nav => nav.classList.remove('active'));
            link.classList.add('active');

            // Show correct tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            document.getElementById(`tab-${targetTab}`).classList.remove('hidden');

            // If switching to Swipe, ensure movies are loaded
            if (targetTab === 'swipe' && movieDeck.length === 0) {
                fetchMovies();
            }
        });
    });

    // Render platform selection checkboxes
    function renderPlatformCheckboxes() {
        const container = document.getElementById('platforms-container');
        container.innerHTML = '';

        PROVIDER_MAP.forEach(provider => {
            const isChecked = currentPreferences.platformIds.includes(provider.id);
            const html = `
                <div class="flex items-center space-x-3 bg-gray-700 p-3 rounded-lg">
                    <input type="checkbox" id="platform-${provider.id}" value="${provider.id}"
                           class="h-5 w-5 text-red-600 bg-gray-600 border-gray-500 rounded focus:ring-red-500"
                           ${isChecked ? 'checked' : ''}>
                    <label for="platform-${provider.id}" class="text-gray-200 flex items-center flex-grow">
                        <img src="${provider.logo}" onerror="this.onerror=null; this.src='https://placehold.co/16x16/374151/ffffff?text=X'" alt="${provider.name} Logo" class="h-6 w-6 rounded mr-1">
                        ${provider.name}
                    </label>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', html);
        });

        // Attach save handler to the button
        document.getElementById('save-settings-btn').onclick = handleSaveSettings;
    }

    // Update settings UI from currentPreferences
    function updateSettingsUI() {
        document.getElementById('country-code').value = currentPreferences.countryCode.toUpperCase();
        renderPlatformCheckboxes();
    }

    // Handle saving settings
    function handleSaveSettings() {
        const countryCode = document.getElementById('country-code').value.toUpperCase();
        const selectedIds = Array.from(document.querySelectorAll('#platforms-container input[type="checkbox"]:checked'))
            .map(cb => parseInt(cb.value));

        if (!countryCode || selectedIds.length === 0) {
            // Simple validation message
            const msgEl = document.getElementById('save-message');
            msgEl.textContent = "Please select at least one platform and enter a country code.";
            msgEl.classList.remove('hidden', 'text-green-500');
            msgEl.classList.add('text-red-500');
            return;
        }

        saveUserPreferences(countryCode, selectedIds, true);
    }
    
    // Render the list of matched movies
    function renderFinalList(matches) {
        finalListEl.innerHTML = '';
        const noMatchesMsg = document.getElementById('no-matches-msg');

        if (matches.length === 0) {
            finalListEl.innerHTML = '<p class="text-gray-400 text-center p-4">No matches yet. Start swiping!</p>';
            return;
        }

        matches.forEach(match => {
            const posterUrl = match.poster_path ? TMDB_IMAGE_BASE_URL + match.poster_path : 'https://placehold.co/100x150/374151/ffffff?text=No+Poster';
            const matchedWithText = match.matchedWith.length > 0
                ? `<span class="text-sm text-green-400">Matched with: ${match.matchedWith.join(', ')}</span>`
                : '<span class="text-sm text-yellow-400">Match Pending...</span>';

            const cardHtml = `
                <div class="flex bg-gray-700 rounded-xl shadow-lg overflow-hidden">
                    <img src="${posterUrl}" onerror="this.onerror=null; this.src='https://placehold.co/100x150/374151/ffffff?text=X'" alt="${match.title} Poster" class="w-20 h-32 object-cover">
                    <div class="p-3 flex-grow">
                        <h3 class="text-lg font-semibold text-white truncate">${match.title}</h3>
                        <p class="text-xs text-gray-400 mb-2">${match.release_date ? match.release_date.substring(0, 4) : 'TBD'}</p>
                        ${matchedWithText}
                        <p class="text-xs text-gray-400 mt-1">Found on ${new Date(match.timestamp).toLocaleDateString()}</p>
                    </div>
                </div>
            `;
            finalListEl.insertAdjacentHTML('beforeend', cardHtml);
        });
    }


    // --- TMDb API LOGIC ---

    // Function to fetch and filter movies based on preferences
    async function fetchMovies() {
        currentMovieIndex = 0; // Reset index for a fresh deck
        movieDeck = []; // Clear existing deck
        movieDeckMap.clear(); // Clear map
        loadingCardEl.classList.remove('hidden');
        noMoviesCardEl.classList.add('hidden');

        if (TMDB_API_KEY === 'YOUR_TMDB_API_KEY' || !isAuthReady) {
            console.error("API Key missing or Auth not ready.");
            loadingCardEl.innerHTML = '<p class="text-red-400">Error: TMDb API Key is missing or Firebase not ready. Please check the console.</p>';
            return;
        }

        const { countryCode, platformIds } = currentPreferences;
        const availableMovies = [];

        try {
            // 1. Get popular movie list (ID, title, poster)
            const popularUrl = `${TMDB_BASE_URL}/discover/movie?api_key=${TMDB_API_KEY}&language=en-US&sort_by=popularity.desc&include_adult=false&include_video=false&page=1&with_watch_monetization_types=flatrate`;
            const popularMovies = await fetch(popularUrl).then(res => res.json());

            if (!popularMovies.results || popularMovies.results.length === 0) {
                loadingCardEl.classList.add('hidden');
                noMoviesCardEl.classList.remove('hidden');
                return;
            }

            // Limit to a reasonable number of initial movies to check
            const moviesToCheck = popularMovies.results.slice(0, 20);

            // 2. Platform Check (Loop)
            for (const movie of moviesToCheck) {
                // Throttle requests slightly to avoid rate limits
                await new Promise(resolve => setTimeout(resolve, 50)); 
                
                const providersUrl = `${TMDB_BASE_URL}/movie/${movie.id}/watch/providers?api_key=${TMDB_API_KEY}`;
                
                let providersResponse;
                try {
                     providersResponse = await fetch(providersUrl).then(res => res.json());
                } catch(e) {
                     console.warn(`Could not fetch providers for movie ${movie.id}:`, e);
                     continue; // Skip this movie if provider fetch fails
                }

                // 3. Filter by Location
                const providers = providersResponse.results[countryCode];

                if (providers && providers.flatrate) {
                    // 4. Filter by Platform: Check if any of the movie's providers are in the user's list
                    const isAvailable = providers.flatrate.some(provider => platformIds.includes(provider.provider_id));

                    if (isAvailable) {
                        // Attach required platform data (name, logo path) to the movie object
                        movie.platforms = providers.flatrate
                            .filter(provider => platformIds.includes(provider.provider_id))
                            .map(p => ({
                                name: p.provider_name,
                                logo_path: TMDB_IMAGE_BASE_URL + p.logo_path
                            }));
                        availableMovies.push(movie);
                        movieDeckMap.set(movie.id, movie); // Store full movie data
                    }
                }
            }

            movieDeck = availableMovies;
            renderMovieDeck();

        } catch (error) {
            console.error("Error fetching or filtering movies:", error);
            loadingCardEl.innerHTML = `<p class="text-red-400">An error occurred during API fetch: ${error.message}</p>`;
        }
    }

    // Call this to reload the deck (e.g., after settings change)
    function resetMovieDeck() {
        // Clear all cards except the loading/no-movies ones
        Array.from(movieStackEl.children).forEach(child => {
            if (!['loading-card', 'no-movies-card'].includes(child.id)) {
                child.remove();
            }
        });
        fetchMovies();
    }

    // --- MOVIE CARD RENDERING & SWIPE LOGIC ---

    function renderMovieDeck() {
        loadingCardEl.classList.add('hidden');

        if (movieDeck.length === 0) {
            noMoviesCardEl.classList.remove('hidden');
            return;
        }

        // Clear previous cards
        Array.from(movieStackEl.children).forEach(child => {
            if (!['loading-card', 'no-movies-card'].includes(child.id)) {
                child.remove();
            }
        });

        movieDeck.forEach((movie, index) => {
            const cardEl = createMovieCard(movie);
            // Stack them visually
            cardEl.style.zIndex = movieDeck.length - index;
            cardEl.style.transform = `translateX(-50%) translateY(${index * 5}px) scale(${1 - index * 0.05})`;

            if (index === 0) {
                attachSwipeListeners(cardEl, movie.id);
            }
            movieStackEl.appendChild(cardEl);
        });
    }

    function createMovieCard(movie) {
        const card = document.createElement('div');
        card.className = 'movie-card';
        card.id = `movie-${movie.id}`;
        card.setAttribute('data-movie-id', movie.id);

        const posterUrl = movie.poster_path ? TMDB_IMAGE_BASE_URL + movie.poster_path : 'https://placehold.co/500x750/374151/ffffff?text=No+Poster+Available';

        const platformLogos = (movie.platforms || []).map(p => `
            <div class="flex items-center text-xs bg-gray-600 px-2 py-1 rounded-full mr-2 mb-2">
                <img src="${p.logo_path}" onerror="this.onerror=null; this.src='https://placehold.co/16x16/374151/ffffff?text=X'" alt="${p.name} logo" class="h-4 w-4 rounded-full mr-1">
                ${p.name}
            </div>
        `).join('');

        card.innerHTML = `
            <div class="movie-card-image" style="background-image: url('${posterUrl}')"></div>
            <div class="movie-card-info">
                <div>
                    <h3 class="text-xl font-bold mb-1 truncate text-white">${movie.title}</h3>
                    <p class="text-sm text-gray-400 mb-2">${movie.release_date ? movie.release_date.substring(0, 4) : 'TBD'}</p>
                    <p class="text-gray-300 text-sm overflow-hidden line-clamp-3 h-12">${movie.overview}</p>
                </div>
                <div>
                    <div class="mt-2 flex flex-wrap items-center">
                        <span class="text-sm text-gray-400 mr-2">Available on:</span>
                        ${platformLogos}
                    </div>
                </div>
            </div>
        `;
        return card;
    }

    // --- SWIPE GESTURE IMPLEMENTATION ---
    function attachSwipeListeners(cardEl, movieId) {
        let startX = 0;
        let currentX = 0;
        let isSwiping = false;

        // Ensure we remove previous listeners before adding new ones
        // This is a simplified implementation, for robustness one would use a dedicated library or store listener references.
        // For this single-page implementation, we only attach to the top card, so we trust it's the only one active.
        
        const onStart = (e) => {
            isSwiping = true;
            startX = (e.touches ? e.touches[0].clientX : e.clientX);
            cardEl.style.transition = 'none'; // Disable transition during drag
        };

        const onMove = (e) => {
            if (!isSwiping) return;

            // Prevent scrolling while dragging horizontally
            if (e.touches && Math.abs(currentX - startX) > 10) {
                 e.preventDefault();
            }

            currentX = (e.touches ? e.touches[0].clientX : e.clientX);
            const deltaX = currentX - startX;
            const rotate = deltaX / 20; // Slight rotation effect

            // Update transform: move, rotate, and slight scale change
            cardEl.style.transform = `translateX(-50%) translateX(${deltaX}px) rotate(${rotate}deg)`;
        };

        const onEnd = () => {
            if (!isSwiping) return;
            isSwiping = false;
            cardEl.style.transition = 'transform 0.3s ease-out'; // Re-enable transition

            const deltaX = currentX - startX;
            const threshold = cardEl.offsetWidth / 3; // Swipe threshold

            let action = null;
            if (deltaX > threshold) {
                // Swipe Right (Like)
                action = 'like';
                cardEl.style.transform = `translateX(-50%) translateX(1000px) rotate(30deg)`;
            } else if (deltaX < -threshold) {
                // Swipe Left (Dislike)
                action = 'dislike';
                cardEl.style.transform = `translateX(-50%) translateX(-1000px) rotate(-30deg)`;
            } else {
                // Reset card position
                cardEl.style.transform = 'translateX(-50%)';
                return;
            }

            // After successful swipe animation, remove card and update stack
            setTimeout(() => {
                cardEl.remove();
                handleSwipe(movieId, action);
                updateCardStack();
            }, 300);
        };

        // Mouse events (for desktop)
        cardEl.addEventListener('mousedown', onStart);
        document.addEventListener('mousemove', onMove);
        document.addEventListener('mouseup', onEnd);

        // Touch events (for mobile)
        cardEl.addEventListener('touchstart', onStart);
        document.addEventListener('touchmove', onMove);
        cardEl.addEventListener('touchend', onEnd);
    }

    // Handle swipe action (save choice to Firestore)
    function handleSwipe(movieId, action) {
        const movieData = movieDeckMap.get(movieId);
        if (!movieData) {
            console.error(`Movie data not found for ID: ${movieId}`);
            return;
        }

        if (action === 'like') {
            // 1. Record the like publicly
            saveSwipeDecision(movieId);
            // 2. Check for a match with other users who may have also liked it
            finalizeMatch(movieId, movieData);
        }
        
        // Dislikes are not recorded in this collaborative model, but we might save them privately 
        // in a future iteration to prevent re-showing the movie.
    }

    // Update the visual stack after a swipe
    function updateCardStack() {
        currentMovieIndex++;
        const remainingCards = movieStackEl.querySelectorAll('.movie-card:not(#loading-card):not(#no-movies-card)');

        if (remainingCards.length === 0) {
            // End of current deck, fetch next page or show 'no movies'
            noMoviesCardEl.classList.remove('hidden');
            return;
        }

        remainingCards.forEach((card, index) => {
            // Only update z-index and transformation for the next card and below
            card.style.transition = 'transform 0.3s ease-out';
            card.style.zIndex = remainingCards.length - index;
            card.style.transform = `translateX(-50%) translateY(${index * 5}px) scale(${1 - index * 0.05})`;

            if (index === 0) {
                // Attach listeners to the new top card
                const nextMovieId = parseInt(card.getAttribute('data-movie-id'));
                attachSwipeListeners(card, nextMovieId);
            }
        });
    }


    // --- APPLICATION START ---
    window.onload = function() {
        initializeFirebase();
    };

    // Initial render of checkboxes (will be updated after Firestore load)
    renderPlatformCheckboxes();
</script>
</body>
</html>
